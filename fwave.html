<!-- ===================== (1/4) UI 텍스트/모달/슬라이더 최적화 준비 ===================== -->
<!-- 1. 버튼 이름 변경 및 오실레이터 추가 모달 준비 -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // [1-1] 버튼 이름 변경
  document.getElementById('add-btn').textContent = '함수 추가';
  document.getElementById('rand-btn').textContent = '무작위 함수';
  document.getElementById('sample-add-btn').textContent = '함수 추가';
  document.getElementById('sample-rand-btn').textContent = '무작위 함수';
  
  // [1-2] 오실레이터 추가 시 모달 입력창 띄우기
  function showOscModal(onOk) {
    const modal = document.getElementById('osc-modal');
    modal.style.display = 'flex';
    // 입력 초기화
    document.getElementById('osc-modal-freq').value = 440;
    document.getElementById('osc-modal-vol').value = 0.5;
    document.getElementById('osc-modal-phase').value = 0;
    // 이벤트 핸들러
    function okHandler() {
      modal.style.display = 'none';
      onOk({
        freq: parseFloat(document.getElementById('osc-modal-freq').value),
        vol: parseFloat(document.getElementById('osc-modal-vol').value),
        phase: parseFloat(document.getElementById('osc-modal-phase').value)
      });
      cleanup();
    }
    function cancelHandler() {
      modal.style.display = 'none';
      cleanup();
    }
    function cleanup() {
      okBtn.removeEventListener('click', okHandler);
      cancelBtn.removeEventListener('click', cancelHandler);
    }
    const okBtn = document.getElementById('osc-modal-ok');
    const cancelBtn = document.getElementById('osc-modal-cancel');
    okBtn.addEventListener('click', okHandler);
    cancelBtn.addEventListener('click', cancelHandler);
    // 엔터키로 확인
    modal.querySelectorAll('input').forEach(inp => {
      inp.onkeydown = e => { if (e.key === 'Enter') okHandler(); };
    });
    // 포커스
    document.getElementById('osc-modal-freq').focus();
  }

  // [1-3] '함수 추가' 버튼 클릭 시 모달로 값 입력받고 오실레이터 추가
  document.getElementById('add-btn').onclick = function() {
    showOscModal(function(val) {
      addOscillator(val.freq, val.vol, val.phase);
    });
  };
  document.getElementById('sample-add-btn').onclick = function() {
    showOscModal(function(val) {
      addSampleOscillator(val.freq, val.vol, val.phase);
    });
  };

  // [1-4] '무작위 함수' 버튼도 모달 없이 랜덤 값으로 추가
  document.getElementById('rand-btn').onclick = function() {
    addOscillator(randomFreq(), randomVol(), randomPhase());
  };
  document.getElementById('sample-rand-btn').onclick = function() {
    addSampleOscillator(randomFreq(), randomVol(), randomPhase());
  };

  // [1-5] 모달 외부 클릭 시 닫기
  document.getElementById('osc-modal').addEventListener('mousedown', function(e) {
    if (e.target === this) this.style.display = 'none';
  });
});
</script>
// ===================== (2/4) 슬라이더 실시간 적용/입력창 자동닫힘/오실레이터 추가 =====================

// [2-1] 오실레이터 추가 함수 (모달에서 값 받아서 호출)
function addOscillator(freq, vol, phase) {
  oscillators.push({
    freq: freq,
    vol: vol,
    phase: phase,
    color: randomColor(),
    active: true
  });
  renderOscillatorList();
  draw();
}
function addSampleOscillator(freq, vol, phase) {
  sampleOscillators.push({
    freq: freq,
    vol: vol,
    phase: phase,
    color: randomColor(),
    active: true
  });
  renderSampleOscillatorList();
  sampleDrawLoop();
}

// [2-2] 슬라이더 실시간 적용 최적화 (iOS/크롬 대응, input 이벤트 사용)
function makeSliderHandler(list, idx, key, render, draw) {
  return function(e) {
    // 'input' 이벤트로 실시간 반영
    let val = parseFloat(e.target.value);
    list[idx][key] = val;
    render();
    draw();
  };
}

// [2-3] 입력창 자동닫힘 문제 해결 (iPad에서 입력 중 포커스 유지)
function makeNumberInputHandler(list, idx, key, render, draw) {
  return function(e) {
    // 값 반영, 포커스 유지
    let val = parseFloat(e.target.value);
    if (!isNaN(val)) {
      list[idx][key] = val;
      render();
      draw();
      // 입력창 닫힘 방지: 포커스 유지
      e.target.focus();
      // 커서 위치 유지
      let len = e.target.value.length;
      e.target.setSelectionRange(len, len);
    }
  };
}

// [2-4] 오실레이터 목록 렌더링 함수 (슬라이더/입력창 핸들러 부착)
function renderOscillatorList() {
  const listDiv = document.getElementById('osc-list');
  listDiv.innerHTML = '';
  oscillators.forEach((osc, idx) => {
    const row = document.createElement('div');
    row.className = 'osc-row';
    row.style.background = osc.active ? '#fff' : '#eee';
    row.innerHTML = `
      <label>f:<input type="number" min="20" max="2000" step="1" value="${osc.freq}"></label>
      <input type="range" min="20" max="2000" step="1" value="${osc.freq}">
      <label>A:<input type="number" min="0" max="1" step="0.01" value="${osc.vol}"></label>
      <input type="range" min="0" max="1" step="0.01" value="${osc.vol}">
      <label>φ:<input type="number" min="0" max="360" step="1" value="${osc.phase}"></label>
      <input type="range" min="0" max="360" step="1" value="${osc.phase}">
      <button class="osc-btn ${osc.active ? 'on' : 'off'}">${osc.active ? 'ON' : 'OFF'}</button>
      <button class="osc-btn del">삭제</button>
      <span class="formula">${osc.vol}·sin(2π·${osc.freq}t${osc.phase ? `+${phaseToPiString(osc.phase)}` : ''})</span>
    `;
    // 슬라이더와 입력창 핸들러 부착
    const inputs = row.querySelectorAll('input[type="number"]');
    const sliders = row.querySelectorAll('input[type="range"]');
    // 주파수
    inputs[0].addEventListener('input', makeNumberInputHandler(oscillators, idx, 'freq', renderOscillatorList, draw));
    sliders[0].addEventListener('input', makeSliderHandler(oscillators, idx, 'freq', renderOscillatorList, draw));
    // 볼륨
    inputs[1].addEventListener('input', makeNumberInputHandler(oscillators, idx, 'vol', renderOscillatorList, draw));
    sliders[1].addEventListener('input', makeSliderHandler(oscillators, idx, 'vol', renderOscillatorList, draw));
    // 위상
    inputs[2].addEventListener('input', makeNumberInputHandler(oscillators, idx, 'phase', renderOscillatorList, draw));
    sliders[2].addEventListener('input', makeSliderHandler(oscillators, idx, 'phase', renderOscillatorList, draw));
    // ON/OFF 버튼
    row.querySelector('.osc-btn.on, .osc-btn.off').onclick = function() {
      oscillators[idx].active = !oscillators[idx].active;
      renderOscillatorList();
      draw();
    };
    // 삭제 버튼
    row.querySelector('.osc-btn.del').onclick = function() {
      oscillators.splice(idx, 1);
      renderOscillatorList();
      draw();
    };
    listDiv.appendChild(row);
  });
}

// [2-5] 샘플 오실레이터 목록 렌더링 (동일 방식)
function renderSampleOscillatorList() {
  const listDiv = document.getElementById('sample-osc-list');
  listDiv.innerHTML = '';
  sampleOscillators.forEach((osc, idx) => {
    const row = document.createElement('div');
    row.className = 'sample-osc-row';
    row.style.background = osc.active ? '#fff' : '#eee';
    row.innerHTML = `
      <label>f:<input type="number" min="20" max="2000" step="1" value="${osc.freq}"></label>
      <input type="range" min="20" max="2000" step="1" value="${osc.freq}">
      <label>A:<input type="number" min="0" max="1" step="0.01" value="${osc.vol}"></label>
      <input type="range" min="0" max="1" step="0.01" value="${osc.vol}">
      <label>φ:<input type="number" min="0" max="360" step="1" value="${osc.phase}"></label>
      <input type="range" min="0" max="360" step="1" value="${osc.phase}">
      <button class="sample-osc-btn ${osc.active ? 'on' : 'off'}">${osc.active ? 'ON' : 'OFF'}</button>
      <button class="sample-osc-btn del">삭제</button>
      <span class="formula">${osc.vol}·sin(2π·${osc.freq}t${osc.phase ? `+${phaseToPiString(osc.phase)}` : ''})</span>
    `;
    // 핸들러 부착 (샘플)
    const inputs = row.querySelectorAll('input[type="number"]');
    const sliders = row.querySelectorAll('input[type="range"]');
    inputs[0].addEventListener('input', makeNumberInputHandler(sampleOscillators, idx, 'freq', renderSampleOscillatorList, sampleDrawLoop));
    sliders[0].addEventListener('input', makeSliderHandler(sampleOscillators, idx, 'freq', renderSampleOscillatorList, sampleDrawLoop));
    inputs[1].addEventListener('input', makeNumberInputHandler(sampleOscillators, idx, 'vol', renderSampleOscillatorList, sampleDrawLoop));
    sliders[1].addEventListener('input', makeSliderHandler(sampleOscillators, idx, 'vol', renderSampleOscillatorList, sampleDrawLoop));
    inputs[2].addEventListener('input', makeNumberInputHandler(sampleOscillators, idx, 'phase', renderSampleOscillatorList, sampleDrawLoop));
    sliders[2].addEventListener('input', makeSliderHandler(sampleOscillators, idx, 'phase', renderSampleOscillatorList, sampleDrawLoop));
    row.querySelector('.sample-osc-btn.on, .sample-osc-btn.off').onclick = function() {
      sampleOscillators[idx].active = !sampleOscillators[idx].active;
      renderSampleOscillatorList();
      sampleDrawLoop();
    };
    row.querySelector('.sample-osc-btn.del').onclick = function() {
      sampleOscillators.splice(idx, 1);
      renderSampleOscillatorList();
      sampleDrawLoop();
    };
    listDiv.appendChild(row);
  });
}
// ===================== (3/4) 파형 그리기(draw), 오실레이터 리스트 초기화, 버튼 연결 =====================

// [3-1] 파형 그리기 함수 (실시간 반영, y축 확대/축소 지원)
function draw() {
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid(ctx, canvas.width, canvas.height, 10, 8);
  const n = 800;
  const t = Array.from({length:n}, (_,i)=>view.tStart + i/view.tSpan*view.tSpan/n);
  let sum = Array(n).fill(0);
  oscillators.forEach((o) => {
    if(o.active) {
      const phi = o.phase * Math.PI / 180;
      for(let i=0; i<n; i++) {
        sum[i] += Math.sin(2*Math.PI*o.freq*t[i] + phi) * o.vol;
      }
    }
  });
  // y축 범위는 view.yMin/yMax 사용
  drawAxes(ctx, canvas.width, canvas.height, view.yMin, view.yMax, view);

  // 파형 그리기
  ctx.save();
  ctx.beginPath();
  for(let i=0; i<n; i++) {
    const x = 40 + (canvas.width-60)*(t[i]-view.tStart)/view.tSpan;
    const y = canvas.height/2 - (sum[i])*((canvas.height-40)/(view.yMax-view.yMin));
    if(i===0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = "#2196f3";
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.95;
  ctx.stroke();
  ctx.restore();
}

// [3-2] 샘플 파형 그리기 함수
function sampleDrawLoop() {
  const canvas = document.getElementById('sample-waveform');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid(ctx, canvas.width, canvas.height, 10, 8);
  const n = 800;
  const t = Array.from({length:n}, (_,i)=>sampleView.tStart + i/sampleView.tSpan*sampleView.tSpan/n);
  let sum = Array(n).fill(0);
  sampleOscillators.forEach((o) => {
    if(o.active) {
      const phi = o.phase * Math.PI / 180;
      for(let i=0; i<n; i++) {
        sum[i] += Math.sin(2*Math.PI*o.freq*t[i] + phi) * o.vol;
      }
    }
  });
  drawAxes(ctx, canvas.width, canvas.height, sampleView.yMin, sampleView.yMax, sampleView);

  ctx.save();
  ctx.beginPath();
  for(let i=0; i<n; i++) {
    const x = 40 + (canvas.width-60)*(t[i]-sampleView.tStart)/sampleView.tSpan;
    const y = canvas.height/2 - (sum[i])*((canvas.height-40)/(sampleView.yMax-sampleView.yMin));
    if(i===0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = "#4caf50";
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.95;
  ctx.stroke();
  ctx.restore();
}

// [3-3] 오실레이터 리스트 및 샘플 오실레이터 리스트 초기 렌더
document.addEventListener('DOMContentLoaded', function() {
  renderOscillatorList();
  renderSampleOscillatorList();
  draw();
  sampleDrawLoop();
});

// [3-4] 주요 버튼 이벤트 연결
document.getElementById('reset-btn').onclick = function() {
  oscillators = [];
  renderOscillatorList();
  draw();
};
document.getElementById('sample-reset-btn').onclick = function() {
  sampleOscillators = [];
  renderSampleOscillatorList();
  sampleDrawLoop();
};
document.getElementById('nc-btn').onclick = function() {
  noiseCancelOn = !noiseCancelOn;
  this.textContent = noiseCancelOn ? '노이즈 캔슬링 ON' : '노이즈 캔슬링 OFF';
  this.classList.toggle('active', noiseCancelOn);
  draw();
};
document.getElementById('sample-nc-btn').onclick = function() {
  sampleNoiseCancelOn = !sampleNoiseCancelOn;
  this.textContent = sampleNoiseCancelOn ? '노이즈 캔슬링 ON' : '노이즈 캔슬링 OFF';
  this.classList.toggle('active', sampleNoiseCancelOn);
  sampleDrawLoop();
};
// ===================== (4/4) 그리드/유틸리티/마무리 연결 =====================

// [4-1] 그리드 그리기 함수
function drawGrid(ctx, width, height, vstep, hstep) {
  ctx.save();
  ctx.strokeStyle = "#eee";
  ctx.lineWidth = 1;
  // 세로선
  for (let x = 40; x < width-10; x += Math.round((width-60)/vstep)) {
    ctx.beginPath();
    ctx.moveTo(x, 10);
    ctx.lineTo(x, height-10);
    ctx.stroke();
  }
  // 가로선
  for (let y = 10; y < height-10; y += Math.round((height-20)/hstep)) {
    ctx.beginPath();
    ctx.moveTo(40, y);
    ctx.lineTo(width-10, y);
    ctx.stroke();
  }
  ctx.restore();
}

// [4-2] draw 함수 마무리 (파형 그리기)
function draw() {
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid(ctx, canvas.width, canvas.height, 10, 8);
  const n = 800;
  const t = Array.from({length:n}, (_,i)=>view.tStart + i/n*view.tSpan);
  let sum = Array(n).fill(0);
  oscillators.forEach((o) => {
    if(o.active) {
      const phi = o.phase * Math.PI / 180;
      for(let i=0; i<n; i++) {
        sum[i] += Math.sin(2*Math.PI*o.freq*t[i] + phi) * o.vol;
      }
    }
  });
  // y축 범위는 view.yMin/yMax 사용
  drawAxes(ctx, canvas.width, canvas.height, view.yMin, view.yMax, view);

  ctx.save();
  ctx.beginPath();
  for(let i=0; i<n; i++) {
    const x = 40 + (canvas.width-60)*(t[i]-view.tStart)/view.tSpan;
    const y = canvas.height/2 - (sum[i])*((canvas.height-40)/(view.yMax-view.yMin));
    if(i===0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = "#2196f3";
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.95;
  ctx.stroke();
  ctx.restore();
}

// [4-3] 샘플 파형 그리기 함수 마무리
function sampleDrawLoop() {
  const canvas = document.getElementById('sample-waveform');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid(ctx, canvas.width, canvas.height, 10, 8);
  const n = 800;
  const t = Array.from({length:n}, (_,i)=>sampleView.tStart + i/n*sampleView.tSpan);
  let sum = Array(n).fill(0);
  sampleOscillators.forEach((o) => {
    if(o.active) {
      const phi = o.phase * Math.PI / 180;
      for(let i=0; i<n; i++) {
        sum[i] += Math.sin(2*Math.PI*o.freq*t[i] + phi) * o.vol;
      }
    }
  });
  drawAxes(ctx, canvas.width, canvas.height, sampleView.yMin, sampleView.yMax, sampleView);

  ctx.save();
  ctx.beginPath();
  for(let i=0; i<n; i++) {
    const x = 40 + (canvas.width-60)*(t[i]-sampleView.tStart)/sampleView.tSpan;
    const y = canvas.height/2 - (sum[i])*((canvas.height-40)/(sampleView.yMax-sampleView.yMin));
    if(i===0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = "#4caf50";
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.95;
  ctx.stroke();
  ctx.restore();
}

// [4-4] 기타 유틸리티 함수 (이미 앞에서 정의된 경우 중복 정의 생략 가능)
function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

// [4-5] DOMContentLoaded에서 전체 초기화
document.addEventListener('DOMContentLoaded', function() {
  renderOscillatorList();
  renderSampleOscillatorList();
  draw();
  sampleDrawLoop();
});

// [4-6] 터치 환경에서 슬라이더 부드럽게 동작하도록 touch-action 스타일 적용
// (이미 CSS에 input[type="range"] { touch-action: none; } 포함됨)

// [4-7] 오실레이터 추가 모달 관련 스타일/이벤트는 이미 (1/4)에서 처리

// [4-8] 전체 코드 끝
</script>
</body>
</html>
