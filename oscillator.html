<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>실시간 사인파 합성기 (자동 y축, 겹침 없는 눈금)</title>
  <style>
    body { font-family: sans-serif; background: #f4f4f4; margin: 0; padding: 0; }
    #controls { background: #fff; padding: 20px; border-bottom: 1px solid #ddd; }
    #osc-list { margin-bottom: 10px; }
    .osc-row { margin-bottom: 8px; }
    .osc-row input[type="number"] { width: 70px; }
    .osc-row label { margin-right: 5px; }
    .osc-row button { margin-left: 10px; }
    #add-btn { margin-top: 10px; }
    #canvas-wrap { text-align: center; margin: 0; background: #fff; }
    canvas { border: 1px solid #bbb; margin: 20px auto; background: #fafafa; }
    .on { background: #4caf50; color: #fff; }
    .off { background: #eee; color: #444; }
    #play-btn {
      font-size: 1.2em; padding: 0.7em 2em; border: none; border-radius: 8px;
      background: #2196f3; color: #fff; margin-bottom: 1em; cursor: pointer;
      margin-right: 1em;
    }
    .formula {
      font-size: 1em;
      margin-left: 1.5em;
      color: #333;
      font-family: 'Consolas', 'Menlo', 'Monaco', monospace;
      background: #f6f6f6;
      border-radius: 6px;
      padding: 2px 8px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="play-btn">▶ 재생</button>
    <div id="osc-list"></div>
    <button id="add-btn">오실레이터 추가</button>
  </div>
  <div id="canvas-wrap">
    <canvas id="waveform" width="820" height="340"></canvas>
  </div>
<script>
function randomColor(alpha=0.35) {
  const r = Math.floor(Math.random()*200+30);
  const g = Math.floor(Math.random()*200+30);
  const b = Math.floor(Math.random()*200+30);
  return `rgba(${r},${g},${b},${alpha})`;
}
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let oscillators = [];
let isPlaying = false;
let masterGain = audioCtx.createGain();
masterGain.gain.value = 1;
masterGain.connect(audioCtx.destination);

function createOscillator(freq, vol, phaseDeg, color) {
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  const gain = audioCtx.createGain();
  gain.gain.value = 0; // 일단 0, 재생할 때만 볼륨 적용
  osc.connect(gain).connect(masterGain);
  osc.start();
  return {
    osc, gain,
    freq, vol,
    phase: phaseDeg,
    color,
    active: true
  };
}

// π 단위 라디안으로 위상 표기
function phaseToPiString(deg) {
  deg = ((deg % 360) + 360) % 360; // 0~359
  if (deg === 0) return '0';
  if (deg === 180) return 'π';
  if (deg === 90) return 'π/2';
  if (deg === 270) return '3π/2';
  // 일반 각도는 소수점 2자리까지 π로 표기
  let frac = +(deg / 180).toFixed(2);
  return `${frac}π`;
}

function updateOscListUI() {
  const list = document.getElementById('osc-list');
  list.innerHTML = '';
  oscillators.forEach((o, idx) => {
    const phiStr = phaseToPiString(o.phase);
    const formula = `y = ${o.vol}·sin(2π·${o.freq}·t + ${phiStr})`;
    const row = document.createElement('div');
    row.className = 'osc-row';
    row.innerHTML = `
      <label style="color:${o.color}; font-weight:bold;">OSC${idx+1}</label>
      <label>주파수(Hz):</label>
      <input type="number" value="${o.freq}" min="20" max="2000" step="1" onchange="setFreq(${idx}, this.value)">
      <label>볼륨(A):</label>
      <input type="number" value="${o.vol}" min="0" max="1" step="0.01" onchange="setVol(${idx}, this.value)">
      <label>위상(°):</label>
      <input type="number" value="${o.phase}" min="0" max="360" step="1" onchange="setPhase(${idx}, this.value)">
      <button class="${o.active?'on':'off'}" onclick="toggleOsc(${idx}, this)">${o.active?'ON':'OFF'}</button>
      <button onclick="removeOsc(${idx})">삭제</button>
      <span class="formula">${formula}</span>
    `;
    list.appendChild(row);
  });
}
window.setFreq = (idx, val) => {
  oscillators[idx].freq = Number(val);
  oscillators[idx].osc.frequency.value = Number(val);
  updateOscListUI();
};
window.setVol = (idx, val) => {
  oscillators[idx].vol = Number(val);
  if (oscillators[idx].active && isPlaying)
    oscillators[idx].gain.gain.value = Number(val);
  else
    oscillators[idx].gain.gain.value = 0;
  updateOscListUI();
};
window.setPhase = (idx, val) => {
  oscillators[idx].phase = Number(val)%360;
  updateOscListUI();
};
window.toggleOsc = (idx, btn) => {
  oscillators[idx].active = !oscillators[idx].active;
  if (isPlaying && oscillators[idx].active)
    oscillators[idx].gain.gain.value = oscillators[idx].vol;
  else
    oscillators[idx].gain.gain.value = 0;
  updateOscListUI();
};
window.removeOsc = (idx) => {
  oscillators[idx].osc.stop();
  oscillators[idx].osc.disconnect();
  oscillators[idx].gain.disconnect();
  oscillators.splice(idx, 1);
  updateOscListUI();
};

document.getElementById('add-btn').onclick = () => {
  unlockAudioContext();
  const color = randomColor();
  const freq = 440; // 주파수 고정
  const vol = 0.5;
  const phase = 0; // 위상 고정
  const osc = createOscillator(freq, vol, phase, color);
  oscillators.push(osc);
  updateOscListUI();
};

function setOscillatorGains() {
  oscillators.forEach(o => {
    o.gain.gain.value = (isPlaying && o.active) ? o.vol : 0;
  });
}

document.getElementById('play-btn').onclick = () => {
  unlockAudioContext();
  isPlaying = !isPlaying;
  setOscillatorGains();
  document.getElementById('play-btn').textContent = isPlaying ? '⏸ 일시정지' : '▶ 재생';
};

updateOscListUI();

// 좌표평면 그리기 함수 (y축 자동 스케일, 눈금 겹침 방지)
function drawAxes(ctx, width, height, tRange, yMin, yMax) {
  ctx.save();
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1;
  ctx.font = "12px sans-serif";
  ctx.fillStyle = "#888";
  ctx.globalAlpha = 1;

  // X축 (시간)
  ctx.beginPath();
  ctx.moveTo(40, height/2);
  ctx.lineTo(width-10, height/2);
  ctx.stroke();

  // Y축 (진폭)
  ctx.beginPath();
  ctx.moveTo(40, 10);
  ctx.lineTo(40, height-10);
  ctx.stroke();

  // X축 눈금 (0~20ms)
  for(let ms=0; ms<=20; ms+=5) {
    let x = 40 + (width-60)*(ms/20);
    ctx.beginPath();
    ctx.moveTo(x, height/2-5);
    ctx.lineTo(x, height/2+5);
    ctx.stroke();
    ctx.fillText(`${ms}ms`, x-12, height/2+20);
  }

  // Y축 눈금 (자동, 겹침 방지)
  let range = yMax - yMin;
  let idealSteps = Math.floor((height-40)/32); // 32px 이상 간격 유지
  let step = Math.pow(10, Math.floor(Math.log10(range)));
  let bestStep = step;
  let bestCount = 1000;
  // 1, 2, 5, 10 계열로 적절히 맞춤
  [1,2,5].forEach(f=>{
    let s = f*step;
    let cnt = Math.ceil(range/s);
    if(cnt<=idealSteps && cnt>1 && Math.abs(cnt-idealSteps)<Math.abs(bestCount-idealSteps)) {
      bestStep = s;
      bestCount = cnt;
    }
  });
  step = bestStep;
  let yStart = Math.ceil(yMin/step)*step;
  let yEnd = Math.floor(yMax/step)*step;
  for(let a=yStart; a<=yEnd+step/2; a+=step) {
    let y = height/2 - (a-((yMax+yMin)/2))*(height-40)/range;
    ctx.beginPath();
    ctx.moveTo(35, y);
    ctx.lineTo(45, y);
    ctx.stroke();
    ctx.fillText(a.toFixed(2), 10, y+4);
  }

  ctx.restore();
}

// 실시간 파형 그리기 (y축 자동 스케일)
function draw() {
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const n = 800;
  const t = Array.from({length:n}, (_,i)=>i/n*0.02); // 0~0.02초(20ms)
  let sum = Array(n).fill(0);

  // 합성파 최대/최소 계산
  let yMax = -Infinity, yMin = Infinity;
  oscillators.forEach((o,idx)=>{
    if(o.active) {
      for(let i=0; i<n; i++) {
        const phi = o.phase*Math.PI/180;
        const y = Math.sin(2*Math.PI*o.freq*t[i] + phi)*o.vol;
        sum[i] += y;
      }
    }
  });
  for(let i=0; i<n; i++) {
    if(sum[i] > yMax) yMax = sum[i];
    if(sum[i] < yMin) yMin = sum[i];
  }
  // y축 최소/최대가 너무 가까우면 -1~+1로 고정
  if (yMax - yMin < 0.1) { yMax = 1; yMin = -1; }

  // 좌표평면
  drawAxes(ctx, canvas.width, canvas.height, [0,0.02], yMin, yMax);

  // 각 오실레이터 파형 그리기
  oscillators.forEach((o,idx)=>{
    if(o.active) {
      ctx.beginPath();
      ctx.strokeStyle = o.color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 1;
      for(let i=0; i<n; i++) {
        const phi = o.phase*Math.PI/180;
        const y = Math.sin(2*Math.PI*o.freq*t[i] + phi)*o.vol;
        const px = 40 + (canvas.width-60)*t[i]/0.02;
        const py = canvas.height/2 - (y-((yMax+yMin)/2))*(canvas.height-40)/(yMax-yMin);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      for(let i=0; i<n; i++) {
        const phi = o.phase*Math.PI/180;
        const y = Math.sin(2*Math.PI*o.freq*t[i] + phi)*o.vol;
        const px = 40 + (canvas.width-60)*t[i]/0.02;
        const py = canvas.height/2 - (y-((yMax+yMin)/2))*(canvas.height-40)/(yMax-yMin);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.lineTo(40 + (canvas.width-60), canvas.height/2);
      ctx.lineTo(40, canvas.height/2);
      ctx.closePath();
      ctx.fillStyle = o.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  });

  // 합성파 그리기 (검정색)
  ctx.beginPath();
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 3;
  for(let i=0; i<n; i++) {
    const px = 40 + (canvas.width-60)*t[i]/0.02;
    const py = canvas.height/2 - (sum[i]-((yMax+yMin)/2))*(canvas.height-40)/(yMax-yMin);
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.stroke();

  requestAnimationFrame(draw);
}
draw();

// 오디오 컨텍스트 정책 대응: 첫 상호작용 시 resume
function unlockAudioContext() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}
// 모든 상호작용(버튼, 입력 등)에 자동 적용
document.body.addEventListener('mousedown', unlockAudioContext, {once:true});
document.body.addEventListener('touchstart', unlockAudioContext, {once:true});
</script>
</body>
</html>
